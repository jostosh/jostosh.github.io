{"data":{"site":{"siteMetadata":{"title":"Machine Learning Blog - JvdW","author":"Jos van de Wolfshaar"}},"markdownRemark":{"id":"dcc32016-c32d-5ee9-8c3f-a748e74e073d","excerpt":"In this post I will cover a partial re-implementation of a recent paper on manifold regularization (Lecouat et al., 2018) for semi-supervised learning with…","html":"<p>In this post I will cover a partial re-implementation of a recent paper on manifold regularization (Lecouat et al., 2018) for semi-supervised learning with Generative Adversarial Networks (Goodfellow et al., 2014). I will attempt to re-implement their main contribution, rather than getting all the hyperparameter details just right. Also, for the sake of demonstration, time constraints and simplicity, I will consider the MNIST dataset rather than the CIFAR10 or SVHN datasets as done in the paper. Ultimately, this post aims at bridging the gap between the theory and implementation for GANs in the semi-supervised learning setting. The code that comes with this post can be found here.</p>\n<h3>Generative Adversarial Networks</h3>\n<p>Let’s quickly go over Generative Adversarial Networks (GAN). In terms of the current pace within the AI/ML community, they have been around for a while (just about 4 years), so you might already be familiar with them. The ‘vanilla’ GAN procedure is to train a <em>generator</em> to generate images that are realistic and capable of fooling a <em>discriminator</em>. The generator generates the images by means of a deep neural network that takes in a noise vector <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"bold-italic\">z</mi></mrow><annotation encoding=\"application/x-tex\">\\boldsymbol z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord boldsymbol\" style=\"margin-right:0.04213em;\">z</span></span></span></span></span>.</p>\n<p>The discriminator (which is a deep neural network as well) is fed with the generated images, but also with some real data. Its job is to say whether each image is either real (coming from the dataset) or fake (coming from the generator), which in terms of implementation comes down to <em>binary classification</em>. The image below summarizes the vanilla GAN setup.</p>\n<p><figure class=\"md-figure\"><img src=\"https://cdn-images-1.medium.com/max/2000/1*k5ry4wcrWGaxtNTqUZFAQQ.png\"><figcaption>&#x3C;i>&#x3C;center>Figure 1: A Vanilla GAN Setup.&#x3C;/center>&#x3C;/i></figcaption></figure></p>\n<h3>Semi-supervised learning</h3>\n<p>Semi-supervised learning problems concern a mix of <em>labeled</em> and <em>unlabeled</em> data. Leveraging the information in both the labeled and unlabeled data to eventually improve the performance on unseen labeled data is an interesting and more challenging problem than merely doing supervised learning on a large labeled dataset. In this case we might be limited to having only about 200 samples per class. So what should we do when only a small portion of the data is labeled?</p>\n<p>Note that adversarial training of <em>vanilla</em> GANs doesn’t require labeled data. At the same time, the deep neural network of the discriminator is able to learn powerful and robust abstractions of images by gradually becoming better at discriminating fake from real. Whatever it’s learning about unlabeled images will presumably also yield useful feature descriptors of labeled images. So how do we use the discriminator for both labeled and unlabeled data? Well, the discriminator is not necessarily limited to just telling fake from real. We could decide to train it to also <em>classify</em> the real data.</p>\n<p>A GAN with a classifying discriminator would be able to exploit both the unlabeled as well as the labeled data. The unlabeled data will be used to merely tell fake from real. The labeled data would be used to optimize the classification performance. In practice, this just means that the discriminator has a <em>softmax</em> output distribution for which we minimize the cross-entropy. Indeed, part of the training procedure is just doing supervised learning. The other part is about adversarial training. The image below summarizes the semi-supervised learning setup with a GAN.</p>\n<p><figure class=\"md-figure\"><img src=\"https://cdn-images-1.medium.com/max/2000/1*Grve_j-Mv4Jgmtq3u7yKyQ.png\"><figcaption>Semi-supervised learning setup with a GAN.</figcaption></figure></p>\n<h2>The implementation</h2>\n<p>Let’s just head over to the implementation, since that might be the best way of understanding what’s happening. The snippet below prepares the data. It doesn’t really contain anything sophisticated. Basically, we take 400 samples per class and concatenate the resulting arrays as being our actual supervised subset. The unlabeled dataset consists of <em>all</em> train data (it also includes the labeled data, since we might as well use it anyway). As is customary for training GANs now, the output of the generator uses a hyperbolic tangent function, meaning its output is between <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span><span class=\"mord\">1</span></span></span></span>. Therefore, we rescale the data to be in that range as well. Then, we create TensorFlow iterators so that we can efficiently go through the data later without having to struggle with feed dicts later on.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">prepare_input_pipeline</span><span class=\"token punctuation\">(</span>flags_obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">(</span>train_x<span class=\"token punctuation\">,</span> train_y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>test_x<span class=\"token punctuation\">,</span> test_y<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>keras<span class=\"token punctuation\">.</span>datasets<span class=\"token punctuation\">.</span>mnist<span class=\"token punctuation\">.</span>load_data<span class=\"token punctuation\">(</span>\n        <span class=\"token string\">\"/home/jos/datasets/mnist/mnist.npz\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">reshape_and_scale</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> img_shape<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span>img_shape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>astype<span class=\"token punctuation\">(</span>np<span class=\"token punctuation\">.</span>float32<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">255</span><span class=\"token punctuation\">.</span> <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span>\n\n    <span class=\"token comment\"># Reshape data and rescale to [-1, 1]</span>\n    train_x <span class=\"token operator\">=</span> reshape_and_scale<span class=\"token punctuation\">(</span>train_x<span class=\"token punctuation\">)</span>\n    test_x <span class=\"token operator\">=</span> reshape_and_scale<span class=\"token punctuation\">(</span>test_x<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># Shuffle train data</span>\n    train_x_unlabeled<span class=\"token punctuation\">,</span> train_y_unlabeled <span class=\"token operator\">=</span> shuffle<span class=\"token punctuation\">(</span>train_x<span class=\"token punctuation\">,</span> train_y<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># Select subset as supervised</span>\n    train_x_labeled<span class=\"token punctuation\">,</span> train_y_labeled <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>flags_obj<span class=\"token punctuation\">.</span>num_classes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        train_x_labeled<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>\n            train_x_unlabeled<span class=\"token punctuation\">[</span>train_y_unlabeled <span class=\"token operator\">==</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>flags_obj<span class=\"token punctuation\">.</span>num_labeled_examples<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        train_y_labeled<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>\n            train_y_unlabeled<span class=\"token punctuation\">[</span>train_y_unlabeled <span class=\"token operator\">==</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>flags_obj<span class=\"token punctuation\">.</span>num_labeled_examples<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    train_x_labeled <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>concatenate<span class=\"token punctuation\">(</span>train_x_labeled<span class=\"token punctuation\">)</span>\n    train_y_labeled <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>concatenate<span class=\"token punctuation\">(</span>train_y_labeled<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">\"InputPipeline\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token keyword\">def</span> <span class=\"token function\">train_pipeline</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> shuffle_buffer_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> tf<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>Dataset<span class=\"token punctuation\">.</span>from_tensor_slices<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\\\n                <span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\\\n                <span class=\"token punctuation\">.</span>shuffle<span class=\"token punctuation\">(</span>buffer_size<span class=\"token operator\">=</span>shuffle_buffer_size<span class=\"token punctuation\">)</span>\\\n                <span class=\"token punctuation\">.</span>batch<span class=\"token punctuation\">(</span>flags_obj<span class=\"token punctuation\">.</span>batch_size<span class=\"token punctuation\">)</span>\\\n                <span class=\"token punctuation\">.</span>repeat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\\\n                <span class=\"token punctuation\">.</span>make_one_shot_iterator<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># Setup pipeline for labeled data</span>\n        train_ds_lab <span class=\"token operator\">=</span> train_pipeline<span class=\"token punctuation\">(</span>\n            <span class=\"token punctuation\">(</span>train_x_labeled<span class=\"token punctuation\">,</span> train_y_labeled<span class=\"token punctuation\">.</span>astype<span class=\"token punctuation\">(</span>np<span class=\"token punctuation\">.</span>int64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            flags_obj<span class=\"token punctuation\">.</span>num_labeled_examples <span class=\"token operator\">*</span> flags_obj<span class=\"token punctuation\">.</span>num_classes<span class=\"token punctuation\">)</span>\n        images_lab<span class=\"token punctuation\">,</span> labels_lab <span class=\"token operator\">=</span> train_ds_lab<span class=\"token punctuation\">.</span>get_next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># Setup pipeline for unlabeled data</span>\n        train_ds_unl <span class=\"token operator\">=</span> train_pipeline<span class=\"token punctuation\">(</span>\n            <span class=\"token punctuation\">(</span>train_x_unlabeled<span class=\"token punctuation\">,</span> train_y_unlabeled<span class=\"token punctuation\">.</span>astype<span class=\"token punctuation\">(</span>np<span class=\"token punctuation\">.</span>int64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>train_x_labeled<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        images_unl<span class=\"token punctuation\">,</span> labels_unl <span class=\"token operator\">=</span> train_ds_unl<span class=\"token punctuation\">.</span>get_next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># Setup another pipeline that also uses the unlabeled data, so that we use a different</span>\n        <span class=\"token comment\"># batch for computing the discriminator loss and the generator loss</span>\n        train_x_unlabeled<span class=\"token punctuation\">,</span> train_y_unlabeled <span class=\"token operator\">=</span> shuffle<span class=\"token punctuation\">(</span>train_x_unlabeled<span class=\"token punctuation\">,</span> train_y_unlabeled<span class=\"token punctuation\">)</span>\n        train_ds_unl2 <span class=\"token operator\">=</span> train_pipeline<span class=\"token punctuation\">(</span>\n            <span class=\"token punctuation\">(</span>train_x_unlabeled<span class=\"token punctuation\">,</span> train_y_unlabeled<span class=\"token punctuation\">.</span>astype<span class=\"token punctuation\">(</span>np<span class=\"token punctuation\">.</span>int64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>train_x_labeled<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        images_unl2<span class=\"token punctuation\">,</span> labels_unl2 <span class=\"token operator\">=</span> train_ds_unl2<span class=\"token punctuation\">.</span>get_next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># Setup pipeline for test data</span>\n        test_ds <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>Dataset<span class=\"token punctuation\">.</span>from_tensor_slices<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>test_x<span class=\"token punctuation\">,</span> test_y<span class=\"token punctuation\">.</span>astype<span class=\"token punctuation\">(</span>np<span class=\"token punctuation\">.</span>int64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\\\n            <span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\\\n            <span class=\"token punctuation\">.</span>batch<span class=\"token punctuation\">(</span>flags_obj<span class=\"token punctuation\">.</span>batch_size<span class=\"token punctuation\">)</span>\\\n            <span class=\"token punctuation\">.</span>repeat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\\\n            <span class=\"token punctuation\">.</span>make_one_shot_iterator<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        images_test<span class=\"token punctuation\">,</span> labels_test <span class=\"token operator\">=</span> test_ds<span class=\"token punctuation\">.</span>get_next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>images_lab<span class=\"token punctuation\">,</span> labels_lab<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>images_unl<span class=\"token punctuation\">,</span> labels_unl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>images_unl2<span class=\"token punctuation\">,</span> labels_unl2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \\\n           <span class=\"token punctuation\">(</span>images_test<span class=\"token punctuation\">,</span> labels_test<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Next up is to define the discriminator network. I have deviated quite a bit from the architecture in the <a href=\"https://arxiv.org/abs/1805.08957\">paper</a>. I’m going to play safe here and just use Keras layers to construct the model. Actually, this enables us to very conveniently reuse all weights for different input tensors, which will prove to be useful later on. In short, the discriminator’s architecture uses 3 convolutions with 5x5 kernels and strides of 2x2, 2x2 and 1x1 respectively. Each convolution is followed by a leaky ReLU activation and a dropout layer with a dropout rate of 0.3. The flattened output of this stack of convolutions will be used as the <em>feature</em> layer.</p>\n<p>The feature layer can be used for a <a href=\"https://arxiv.org/abs/1606.03498\">feature matching loss</a> (rather than a sigmoid cross-entropy loss as in vanilla GANs), which has proven to yield a more reliable training process. The part of the network up to this feature layer is defined in <em>define</em>tail in the snippet below. The <em>define</em>head method defines the rest of the network. The ‘head’ of the network introduces only one additional fully connected layer with 10 outputs, that correspond to the logits of the class labels. Other than that, there are some methods to make the interface of a Discriminator instance behave similar to that of a <code class=\"language-text\">tf.keras.models.Sequential</code> instance.</p>\n<iframe src=\"https://medium.com/media/f7cddea47aa891e6a870308f6fb41a8b\" frameborder=0></iframe>\n<p>The generator’s architecture also uses 5x5 kernels. Many implementations of DCGAN-like architectures use transposed convolutions (sometimes wrongfully referred to as ‘deconvolutions’). I have decided to give the <em>upsampling-convolution</em> alternative a try. This should alleviate the issue of the <a href=\"https://distill.pub/2016/deconv-checkerboard/\">checkerboard pattern</a> that sometimes appears in generated images. Other than that, there are ReLU nonlinearities, and a first layer to go from the 100-dimensional noise to a (rather awkwardly shaped) 7x7x64 spatial representation.</p>\n<iframe src=\"https://medium.com/media/5bdb5668845147a411a03d6dc642ed13\" frameborder=0></iframe>\n<p>I have tried to make this model work with what TensorFlow’s Keras layers have to offer so that the code would be easy to digest (and to implement of course). This also means that I have deviated from the architectures in <a href=\"https://arxiv.org/abs/1805.08957\">the paper</a> (e.g. I’m not using weight normalization). Because of this experimental approach, I have also experienced just how sensitive the training setup is to small variations in network architectures and parameters. There are plenty of neat GAN ‘hacks’ listed <a href=\"https://github.com/soumith/ganhacks\">here</a> which I definitely found insightful.</p>\n<h3>Putting it together</h3>\n<p>Let’s do the forward computations now so that we see how all of the above comes together. This consists of setting up the input pipeline, noise vector, generator and discriminator. The snippet below does all of this. Note that when define_generator returns the Sequential instance, we can just use it as a functor to obtain the output of it for the noise tensor given by <strong><em>z</em></strong>.</p>\n<p>The discriminator will do a lot more. It will take (i) the ‘fake’ images coming from the generator, (ii) a batch of unlabeled images and finally (iii) a batch of labeled images (both with and <strong>*without *</strong>dropout to also report the train accuracy). We can just repetitively call the Discriminator instance to build the graph for each of those outputs. Keras will make sure that the variables are reused in all cases. To turn off dropout for the labeled training data, we have to pass training=False explicitly.</p>\n<iframe src=\"https://medium.com/media/5492fe8adddee711f11786229c81e8a0\" frameborder=0></iframe>\n<h3>The discriminator’s loss</h3>\n<p>Recall that the discriminator will be doing more than just separating fake from real. It also classifies the labeled data. For this, we define a supervised loss which takes the softmax output. In terms of implementation, this means that we feed the unnormalized logits to tf.nn.sparse<em>cross</em>entropy<em>with</em>logits.</p>\n<p>Defining the loss for the unsupervised part is where things get a little bit more involved. Because the softmax distribution is overparameterized, we can fix the <em>unnormalized logit</em> at 0 for an image to be fake (i.e. coming from the generator). If we do so, the probability of it being real just turns into:</p>\n<p><figure class=\"md-figure\"><img src=\"https://cdn-images-1.medium.com/max/2000/1*l9lzsjJKLMp2XcwpziFkmw.png\"><figcaption>Probability of observing a fake image</figcaption></figure><em>Probability of observing a fake image</em></p>\n<p>where <em>Z(x)</em> is the sum of the* unnormalized probabilities*. Note that we currently only have the logits. Ultimately, we want to use the log-probability of the fake class to define our loss function. This can now be achieved by computing the whole expression in log-space:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/3574/1*3QHLafdgqmd5vFMaKSoQbQ.png\"></p>\n<p>Where the lower case <em>l</em> with subscripts denote the individual logits. Divisions become subtractions and sums can be computed by the logsumexp function. Finally, we have used the definition of the <em>softplus</em> function:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*dpEsjtSN3YtzTr8mc7rknw.png\"></p>\n<p>In general, if you have the log-representation of a probability, it is numerically safer to keep things in log-space for as long as you can, since we are able to represent much smaller numbers in that case.</p>\n<p>We’re not there yet. Generative adversarial training asks us to ascend the gradient of:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*n-ARqnvI4nEsBOuuIQ61eA.png\"></p>\n<p>So whenever we call tf.train.AdamOptimizer.minimize we should <em>descent</em>:</p>\n<p><figure class=\"md-figure\"><img src=\"https://cdn-images-1.medium.com/max/3388/1*QG2YK4uvJCVYXMrFsmmqoQ.png\"><figcaption>Time to rewrite this though…</figcaption></figure><em>Time to rewrite this though…</em></p>\n<p>The first term on the right-hand side of the equation can be written:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/4768/1*m7Yj5icm4kVaAWlvassnnA.png\"></p>\n<p>The second term of the right-hand side can be written as:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/7828/1*ji0rb_RrNFQvFSUVVDEIFA.png\"></p>\n<p>So that finally, we arrive at the following loss:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/7954/1*_3YqX5Ppo5keIk1anwx21g.png\"></p>\n<iframe src=\"https://medium.com/media/4da4cfc994700273074d3419ecbce8d9\" frameborder=0></iframe>\n<h3>Optimizing the discriminator</h3>\n<p>Let’s setup the operations for actually updating the parameters of the discriminator. We will just reside to the Adam optimizer. While tweaking the parameters before I wrote this post, I figured I might slow down the discriminator by setting its learning rate at 0.1 times that of the generator. After that my results got much better, so I decided to leave it there for now. Notice also that we can very easily select the subset of variables corresponding to the discriminator by exploiting the encapsulation offered by Keras.</p>\n<iframe src=\"https://medium.com/media/a74419fb9788f1b309e383c40b94d20d\" frameborder=0></iframe>\n<h3>Adding some control flow to the graph</h3>\n<p>After we have the new weights for the discriminator, we want the generator’s update to be aware of the updated weights. TensorFlow will not guarantee that the updated weights will actually be used even if we were to redeclare the forward computation after defining the minimization operations for the discriminator. We can still force this by using tf.control_dependencies. Any operation defined in the scope of this context manager will depend on the evaluation of the ones that are passed to context manager at <em>instantiation</em>. In other words, our generator’s update that we define later on will be guaranteed to compute the gradients using the <em>updated weights</em> of the discriminator.</p>\n<iframe src=\"https://medium.com/media/715b51eb3e68cfd8f893995bdb406736\" frameborder=0></iframe>\n<h3>The generator’s loss and updates</h3>\n<p>In this implementation, the generator tries to minimize the L2 distance of the* average* <em>features</em> of the generated images vs. the <em>average features</em> of the real images. This <a href=\"https://arxiv.org/abs/1606.03498\">feature-matching loss</a> (Salimans et al., 2016) has proven to be more stable for training GANs than directly trying to optimize the discriminator’s probability for observing real data. It is straightforward to implement. While we’re at it, let’s also define the update operations for the generator. Notice that the learning rate of this optimizer is 10 times that of the discriminator.</p>\n<iframe src=\"https://medium.com/media/50da4b93a30db5d07122bad194571038\" frameborder=0></iframe>\n<h3>Adding manifold regularization</h3>\n<p><a href=\"https://arxiv.org/abs/1805.08957\">Lecouat et. al</a> (2018) propose to add *manifold regularization *to the feature-matching GAN training procedure of <a href=\"https://arxiv.org/abs/1606.03498\">Salimans et al. (2016)</a>. The regularization forces the discriminator to yield similar logits (unnormalized log probabilities) for nearby points in the latent space in which <strong>*z *</strong>resides. It can be implemented by generating a second perturbed version of <strong>*z *</strong>and computing the generator’s and discriminator’s outputs once more with this slightly altered vector.</p>\n<p>This means that the noise generation code looks as follows:</p>\n<iframe src=\"https://medium.com/media/c1f080b1f0e3fd0ccaf381a55ce31d9f\" frameborder=0></iframe>\n<p>The discriminator’s loss will be updated as follows (note the 3 extra lines at the bottom):</p>\n<iframe src=\"https://medium.com/media/12da948e8fa652d507a3244ea0f19391\" frameborder=0></iframe>\n<h3>Classification performance</h3>\n<p>So how does it really perform? I have provided a few plots below. There are many things I might try to squeeze out additional performance (for instance, just training for longer, using a learning rate schedule, implementing weight normalization), but the main purpose of writing this post was to get to know a relatively simple yet powerful semi-supervised learning approach. After 100 epochs of training, the mean test accuracy approaches 98.9 percent.</p>\n<p>The full script can be found <a href=\"https://github.com/jostosh/gan\">here</a>. Thanks for reading!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*6Id2ap-9mQ-pMQKBDYqC1A.jpeg\"></p>","frontmatter":{"title":"Semi-Supervised Learning With GANs","date":"June 18, 2018","description":"Partial reimplementation of a paper on Semi-Supervised Learning with Generative Adversarial Networks."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/ssl-gan/","previous":{"fields":{"slug":"/capsnet-cuda/"},"frontmatter":{"title":"Cuda, TensorFlow And Capsule Networks"}},"next":{"fields":{"slug":"/spn01/"},"frontmatter":{"title":"Sum-Product Networks"}}}}