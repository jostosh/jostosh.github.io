{"data":{"site":{"siteMetadata":{"title":"Machine Learning Blog - JvdW","author":"Jos van de Wolfshaar"}},"markdownRemark":{"id":"6755a274-1839-57b9-81a5-9da58634bf40","excerpt":"Sum-Product Networks (SPNs) are probabilistic graphical models (PGMs) that have been around for several years, with arguably a limited amount of attention from…","html":"<div><p>Sum-Product Networks (SPNs) are probabilistic graphical models (PGMs) that have been around for several years, with arguably a limited amount of attention from the machine learning community. I believe this is due to several things. First, the daunting success of advanced deep neural networks like convolutional neural networks and recurrent neural networks overruled much of the alternative methods that may seem inferior at first sight. Second, SPNs are nontrivial to implement in a tensorized fashion (especially when compared to CNNs or RNNs). Third, SPNs come with a rich terminology and a strict probabilistic interpretation that might seem less intuitive then 'cells that fire together wire together'. This series of posts aims at addressing these issues to varying extent by going through some basic intuitions behind SPNs, showing how to implement SPNs in a tensorized fashion and finally, looking at a hands-on example of SPNs for generative and discriminative learning on image datasets.</p><p>Quite some time ago, I joined a project where we worked on a library with 'tensorized' implementations of SPNs, known as libspn. The library leverages the flexibility and power of TensorFlow to bring SPNs to the broader ML audience. Although by now it is something I need to pursue in my spare time, I like working on it since it sets some unique engineering challenges. I'll explain the complexity of this challenge over the next few posts.</p><p>This series of posts assumes basic knowledge of set theory, probability theory, neural networks and 'tensor-based' programming and computing.</p><h2>Sum-Product Networks: An Intro</h2><p>Sum-Product Networks are probabilistic graphical models (PGMs). This implies they resemble a probability distribution (either continuous or discrete). Implementation-wise, this means that our computation takes in random variables on one side and spits out probabilities on another side. Note that this is qualitatively different from multi-layer perceptrons (MLPs). For MLPs the output might be framed probabilistically, such as the softmax output for classification:\n$$\np(y<em>i \\mid \\boldsymbol X) = \\frac{\\exp(\\boldsymbol w</em>i^T \\boldsymbol h)}{\\sum<em>k \\exp(\\boldsymbol w</em>k ^T \\boldsymbol h)}\n$$</p><p>Nevertheless, the inputs (often image pixels) are just the raw numbers fed to the network, without any explicit probabilistic interpretation. Also, all intermediate layers in an MLP lack a direct probabilistic interpretation.</p><p>Since SPNs are recursive tree-like structures, non-root nodes are roots of sub-SPNs with a probabilistic interpretation similar to the full SPN. In fact, often SPNs are thought of as hierarchical probabilistic models. In other words, the interpretation of nodes in SPNs differs significantly from hidden neurons in an MLP!</p><h2>What Can SPNs Be Used For?</h2><p>SPNs can be used for tasks like image completion, localization for robotics, classification and can be trained to tackle either unsupervised or supervised or semi-supervised problems. Depending on the task and whether we want the SPN to optimize for generative or discriminative abilities, we can train the SPN with expectation maximization (EM), gradient descent (GD), extended Baum-Welch (EBW) and more algorithms. In some cases, SPNs are trained for generative and discriminative abilities simultaneously. We'll cover the training of an SPN in a follow-up post where we'll be closer to the implementation.</p><h2>A Shift In Terminology</h2><p>For SPNs: </p><ul>\n<li>Inputs are called leaves;</li>\n<li>Neurons are called nodes;</li>\n<li>Each leaf node belongs to a single random variable. There can be multiple leaf nodes per random variable. For continuous variables, the leaves that correspond to a variable are the variable's components. For discrete categorical variables, the leaves that belong to a variable are the variable's indicators (i.e. $[X<em>1=0, X</em>1=1, \\ldots]$).</li>\n<li>A set of variables is called a scope. Leaf nodes have scopes of exactly one variable e.g. ${X<em>1}$ or ${X</em>2}$. For a non-leaf node, the scope of the node corresponds to the union of the scopes of its children. If a parent node has two children with scopes ${X<em>i}$ and ${X</em>j}$, then that parent has the scope ${X<em>i, X</em>j}$\nThe node at the top of the tree-structure is called the root.</li>\n</ul><p>In other words, SPNs are directed acyclic graphs with a tree-like structure.\nThe leaves of an SPN are random variables $\\boldsymbol X = [X<em>1, X</em>2, \\ldots, X_N]$. Additionally, each operation in an SPN must preserve the ability to interpret the computed values as probabilities. This means that the value of every node in the forward pass computes a probability. As a result, a high degree of interpretability comes for free with SPNs.</p><h2>Guaranteeing a Probabilistic Interpretation</h2><p>So exactly how do we make sure that any node at any layer in an SPN computes an exact probability? In the original SPN paper by Poon and Domingo's [1], this is more formally defined as preserving the property of validity throughout the SPN. Roughly speaking, valid SPNs efficiently and accurately model a joint probability. For a  thorough treatment of validity, I suggest you read the original paper [1] and have a look at Poupart's excellent lectures (first and second) on SPNs. For the purpose of these blog posts, we mostly care about how we create valid SPNs. Valid SPNs can be created by</p><ol>\n<li>Restricting ourselves to (i) non-negative weighted sums and (ii) products for propagating probabilities upward;</li>\n<li>Ensuring that the descendant random variables of children of a sum node are identical;</li>\n<li>Ensuring that the descendant random variables of  children of a product node are pairwise mutually disjoint;</li>\n</ol><p>Let's look at the restriction of non-negative weighted sums first and products first. A non-negative weighted sum of probabilities occurs in many probabilistic (graphical) models. Usually, the non-negative weights correspond to prior probabilities of the children of the sum. Note that to interpret the weights as probabilities we not only require them to be non-negative but we also must also ensure that they sum up to exactly one, i.e. $\\sum<em>i w</em>{ij} = 1$.</p><h2>A Mixture of Gaussians as an SPN</h2><p>A common scenario is to have a mixture of Gaussians to model a single random variable:\n$$\np(x) = \\sum<em>k \\underbrace{p(x \\mid z=k)}</em>{\\text{Component: } \\mathcal N(\\mu, \\sigma^2)} \\underbrace{p(z=k)}_{\\text{Prior (a scalar)}}\n$$</p><p>Sum nodes in SPNs compute probabilities in the same way, but the 'components' can be either (i) leaf nodes or (ii) sub-SPNs. The equation above is equivalent to the extremely simple SPN below (when replacing $z$ with $X_1$):</p><p>Note that in the SPN above, we compute a sum over elements that consider the same singular set of variables, namely ${X_1}$. The leaf nodes correspond to the Gaussian components while the edges correspond to the non-negative weights. The value of the root corresponds to $p(x)$ in Equation 1.</p><p>In SPN terminology, a set of variables is called a scope. Leaf nodes have scopes of exactly one variable e.g. ${X<em>1}$ or ${X</em>2}$. Note that the SPN in Figure 1 satisfies at least requirements 1 and 2 for a valid SPN, provided we have non-negative weights. The second requirement of having identical scopes for the sum's children is also known as the completeness property. The SPN in Figure 1 does not include products, so we don't really care about the third requirement. Hence, all boxes are ticked and this SPN is valid!</p><h2>Computing Joint Probabilities</h2><p>What about the third requirement? Well, if we have an SPN defined over more than one variable, we should join scopes to eventually obtain a root node that computes the joint probability over the variables contained in those scopes. The third requirement describes under which conditions we can join scopes in a valid SPN. It is also known as the decomposability property. It might not be the first time you've heard that when computing the joint probability over two independent variables, you can simply multiply the individual probabilities, e.g. $p(x,y) = p(x)p(y)$. Sum-product networks compute joint probabilities in the same way: they multiply several probabilities to obtain a new joint probability.</p><p>Consider the following SPN:</p><p>The SPN above computes the following probability mass function:\n$$\np(\\boldsymbol X<em>1, \\boldsymbol X</em>2) = w<em>1 X</em>1 X<em>2 + w</em>2 X<em>1 \\bar{X</em>2} + w<em>3 \\bar{X</em>1} X<em>2 + w</em>4 \\bar{X<em>1} \\bar{X</em>2}\n$$</p><p>Clearly, the SPN in Figure 2 is a bit more sophisticated than the one in Figure 1. First of all, it is multi-layered. The first layer on top of the leaves consists of products of which the children have pairwise disjoint scopes (requirement 3). The scopes of the 4 products are identical (namely ${X<em>1, X</em>2}$). Consequently, we can combine those probabilities with a sum node at the top of the SPN (the root). To compute the probability of a particular assignment of indicators, we replace the indicators that are included with 1 and those that are excluded with 0:</p><p>$$\np(X<em>1, X</em>2) = w<em>1 \\cdot 1 \\cdot 1 + w</em>2 \\cdot 0 \\cdot 1 + w<em>3 \\cdot 0 \\cdot 1 + w</em>4 \\cdot 0 \\cdot 0 = w_1\n$$</p><p>Or, alternatively:</p><p>$$\np(\\bar{X<em>1}, X</em>2) = w<em>1 \\cdot 0 \\cdot 1 + w</em>2 \\cdot 0 \\cdot 0 + w<em>3 \\cdot 1 \\cdot 1 + w</em>4 \\cdot 1 \\cdot 0 = w_3\n$$</p><p>If one of the two variables is unknown, we can easily 'marginalize out' this variable by setting both its indicators to 1:</p><p>$$\np(X<em>1) = w</em>1 1\\cdot 1 + w<em>2 \\cdot 1 \\cdot 1 + w</em>3 \\cdot 0 \\cdot 0 + w<em>4 = w</em>1 + w_2\n$$</p><h2>Stacking Layers</h2><p>The scopes of a product's children can contain more than a single random variable. Consider the following SPN:</p><p>Figure 3 displays an SPN with even more layers than the one in Figure 2. The first product layer combines either ${X<em>1}$ and ${X</em>2}$ into ${X<em>1, X</em>2}$ (the blue products) or ${X<em>3}$ and ${X</em>4}$ into ${X<em>3, X</em>4}$ (the orange products). The blue product nodes are followed up by the green sum nodes and the orange product nodes by the pink sum nodes (they do not alter the scope, but merely 'mix' the probabilities of the underlying scopes). These green and pink nodes have scopes with two variables each. Moreover, if we take one green node and one pink node, then that results in pairwise disjoint sets, so we can safely join those scopes by a product node (the grey nodes at the penultimate layer). Finally, all the grey nodes at the penultimate layer have identical scopes, so we can 'mix' those probabilities in the final root sum.</p><p>Check out the overview of the scopes on the right of Figure 3 and verify yourself that the SPN is indeed decomposable by checking the products' children's scopes for pairwise mutual exclusiveness and complete by checking the sums' children's scopes for being identical. In case these two properties check out, that means the SPN is valid!</p><p>Note that the architecture in the SPNs above is arbitrary (as long as they are decomposable and complete that is), so we can easily increase the number of sums per layer, reduce the number of products per layer etc. However, for the purpose of illustration, I've kept things relatively simple.</p><h2>What's Next</h2><p>Hope you're still with me because there's more to come! At this point, we have only touched on the basic terminology and some simple architectures. In the next post, we'll be looking into the actual implementation of SPNs in a tensorized fashion, after which it becomes easy to experiment with them.</p><h2>References</h2><ol>\n<li>Poon, Hoifung, and Pedro Domingos. \"Sum-product networks: A new deep architecture.\" 2011 IEEE International Conference on Computer Vision Workshops (ICCV Workshops). IEEE, 2011.</li>\n<li>Zheng, Kaiyu, Andrzej Pronobis, and Rajesh PN Rao. \"Learning graph-structured sum-product networks for probabilistic semantic maps.\" Thirty-Second AAAI Conference on Artificial Intelligence. 2018.</li>\n<li>Gens, Robert, and Pedro Domingos. \"Discriminative learning of sum-product networks.\" Advances in Neural Information Processing Systems. 2012.</li>\n</ol><p><img src=\"./content/blog/hello-world/spn_two_vars.png\" alt=\"Two Vars\"></p><script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> <div>\n    <div id=\"f08a30b7-dd7b-4530-b5d6-6e875dac1cbd\" class=\"plotly-graph-div\" style=\"height:100%; width:100%;\"></div>\n    <script type=\"text/javascript\">\n            window.PLOTLYENV=window.PLOTLYENV || {};\n            window.PLOTLYENV.BASE_URL='https://plot.ly';\n        if (document.getElementById(\"f08a30b7-dd7b-4530-b5d6-6e875dac1cbd\")) {\n            Plotly.newPlot(\n                'f08a30b7-dd7b-4530-b5d6-6e875dac1cbd',\n                [{\"hoverinfo\": \"none\", \"line\": {\"color\": \"rgb(210,210,210)\", \"width\": 1}, \"mode\": \"lines\", \"showlegend\": false, \"type\": \"scatter\", \"uid\": \"b0fc1806-6852-4163-a7ee-5440f5f37bc6\", \"x\": [-4.0, -4.0, null, -1.7142857142857144, -4.0, null, -4.0, -2.857142857142857, null, -0.5714285714285716, -2.857142857142857, null, -2.857142857142857, -1.7142857142857144, null, -1.7142857142857144, -1.7142857142857144, null, -2.857142857142857, -0.5714285714285716, null, -0.5714285714285716, -0.5714285714285716, null, 0.5714285714285712, 0.5714285714285712, null, 2.8571428571428568, 0.5714285714285712, null, 0.5714285714285712, 1.7142857142857135, null, 4.0, 1.7142857142857135, null, 1.7142857142857135, 2.8571428571428568, null, 2.8571428571428568, 2.8571428571428568, null, 1.7142857142857135, 4.0, null, 4.0, 4.0, null, -4.0, -2.0, null, -2.857142857142857, -2.0, null, -1.7142857142857144, -2.0, null, -0.5714285714285716, -2.0, null, -4.0, -0.6666666666666667, null, -2.857142857142857, -0.6666666666666667, null, -1.7142857142857144, -0.6666666666666667, null, -0.5714285714285716, -0.6666666666666667, null, 0.5714285714285712, 0.6666666666666665, null, 1.7142857142857135, 0.6666666666666665, null, 2.8571428571428568, 0.6666666666666665, null, 4.0, 0.6666666666666665, null, 0.5714285714285712, 2.0, null, 1.7142857142857135, 2.0, null, 2.8571428571428568, 2.0, null, 4.0, 2.0, null, -2.0, -2.0, null, 0.6666666666666665, -2.0, null, -2.0, -0.6666666666666667, null, 2.0, -0.6666666666666667, null, -0.6666666666666667, 0.6666666666666665, null, 0.6666666666666665, 0.6666666666666665, null, -0.6666666666666667, 2.0, null, 2.0, 2.0, null, -2.0, 0, null, -0.6666666666666667, 0, null, 0.6666666666666665, 0, null, 2.0, 0, null], \"y\": [1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 1, 2, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 2, 3, null, 3, 4, null, 3, 4, null, 3, 4, null, 3, 4, null, 3, 4, null, 3, 4, null, 3, 4, null, 3, 4, null, 4, 5, null, 4, 5, null, 4, 5, null, 4, 5, null]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(141,211,199)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle\"}, \"mode\": \"markers+text\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{1}\\\\}$\", \"text\": [\"$X_{1}$\", \"$\\\\bar{X_{1}}$\"], \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"b98a2fbb-a09c-4692-8340-c4bb31d6c5c9\", \"x\": [-4.0, -2.857142857142857], \"y\": [1, 1]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(255,255,179)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle\"}, \"mode\": \"markers+text\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{2}\\\\}$\", \"text\": [\"$X_{2}$\", \"$\\\\bar{X_{2}}$\"], \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"2920ced8-4267-438c-b0ce-f5532f350cbe\", \"x\": [-1.7142857142857144, -0.5714285714285716], \"y\": [1, 1]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(190,186,218)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle\"}, \"mode\": \"markers+text\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{3}\\\\}$\", \"text\": [\"$X_{3}$\", \"$\\\\bar{X_{3}}$\"], \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"fb3c9e47-7d1f-4d86-b7c4-464a66f4067e\", \"x\": [0.5714285714285712, 1.7142857142857135], \"y\": [1, 1]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(251,128,114)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle\"}, \"mode\": \"markers+text\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{4}\\\\}$\", \"text\": [\"$X_{4}$\", \"$\\\\bar{X_{4}}$\"], \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"070f64ed-7034-4fdc-b142-5115e9d33ce9\", \"x\": [2.8571428571428568, 4.0], \"y\": [1, 1]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(128,177,211)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle-x\"}, \"mode\": \"markers\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{1},X_{2}\\\\}$\", \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"98554b88-4403-4365-b780-6eff6b110058\", \"x\": [-4.0, -2.857142857142857, -1.7142857142857144, -0.5714285714285716], \"y\": [2, 2, 2, 2]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(253,180,98)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle-x\"}, \"mode\": \"markers\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{3},X_{4}\\\\}$\", \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"ca63d2e8-9940-45ba-a279-54c0768b5459\", \"x\": [0.5714285714285712, 1.7142857142857135, 2.8571428571428568, 4.0], \"y\": [2, 2, 2, 2]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(179,222,105)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle-cross\"}, \"mode\": \"markers\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{1},X_{2}\\\\}$\", \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"464102db-2100-43b2-8942-326831574259\", \"x\": [-2.0, -0.6666666666666667], \"y\": [3, 3]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(252,205,229)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle-cross\"}, \"mode\": \"markers\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{3},X_{4}\\\\}$\", \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"823b3f38-4e60-4f3e-a31e-6b95fe7e3420\", \"x\": [0.6666666666666665, 2.0], \"y\": [3, 3]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(217,217,217)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle-x\"}, \"mode\": \"markers\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{1},X_{2},X_{3},X_{4}\\\\}$\", \"textposition\": \"bottom center\", \"type\": \"scatter\", \"uid\": \"7c16cf71-ba0a-4c07-9329-e0d6df5ef8db\", \"x\": [-2.0, -0.6666666666666667, 0.6666666666666665, 2.0], \"y\": [4, 4, 4, 4]}, {\"hoverinfo\": \"name\", \"marker\": {\"color\": \"rgb(188,128,189)\", \"line\": {\"color\": \"rgb(50,50,50)\", \"width\": 1}, \"size\": 18, \"symbol\": \"circle-cross\"}, \"mode\": \"markers+text\", \"name\": \"$\\\\text{Scope}(n)=\\\\{X_{1},X_{2},X_{3},X_{4}\\\\}$\", \"text\": [\"Root\"], \"textposition\": \"top center\", \"type\": \"scatter\", \"uid\": \"d711baff-eb2c-46a7-8094-16655bcc4b61\", \"x\": [0], \"y\": [5]}],\n                {\"font\": {\"family\": \"Times New Roman\", \"size\": 12}, \"hovermode\": \"closest\", \"legend\": {\"traceorder\": \"reversed\"}, \"showlegend\": true, \"xaxis\": {\"showgrid\": false, \"showline\": false, \"showticklabels\": false, \"zeroline\": false}, \"yaxis\": {\"range\": [-2, 7], \"showgrid\": false, \"showline\": false, \"showticklabels\": false, \"zeroline\": false}},\n                {\"showLink\": false, \"responsive\": true, \"linkText\": \"Export to plot.ly\", \"plotlyServerURL\": \"https://plot.ly\"}\n            )\n        };\n    </script>\n</div></div>","frontmatter":{"title":"Tensorizing Sum-Product Networks","date":"June 11, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/hello-world/","previous":{"fields":{"slug":"/hi-folks/"},"frontmatter":{"title":"New Beginnings"}},"next":null}}